---
title: "01 - First baby steps: R, Importing Data, and Manipulating Data"
output: 
     html_notebook:
          toc: true
          toc_float: true
---

# What is R? 

R is a ‘programming environment for statistics and graphics’

* Does basically everything, can also be extended
* It’s the default when statisticians implement new methods
* Free, open-source

But;

* Steeper learning curve than e.g. Excel, Stata
* Command-line driven (programming, not drop-down menus)
* Gives only what you ask for!


To help with these difficulties, we will begin with RStudio, a graphical user interface (front-end) for R that is slightly more user-friendly than ‘Classic’ R’s GUI.


# Trying out the Console

We’ll use the ‘Console’ window first – as a (fancy!) calculator
```{r}
2+2
# [1] 4

2^5+7
# [1] 39

2^(5+7)
# [1] 4096

exp(pi)-pi
# [1] 19.9991

log(20+pi)
# [1] 3.141632

0.05/1E6 # a comment; note 1E6 = 1,000,000
# [1] 5e-08

```

* All common math functions are available; parentheses (round brackets) work as per high school math
* Try to get used to bracket matching. A ‘+’ prompt means the line isn’t finished – hit Escape to get out, then try again.

We can also compare things in R using **operators**.

We can see if things are equal by using two equal signs `==`.  To see if something is NOT equal, we use the exclamation mark `!`.
```{r}
3 == 2
# [1] FALSE

3-1 == 2
# [1] TRUE

TRUE == TRUE
# [1] TRUE

TRUE == FALSE
#[1] FALSE

'a' == 'a'
# [1] TRUE

'abc' != 'ABC'
# [1] TRUE

!is.na(NA)
# [1] FALSE
```
**Note:** We can represent missing data with `NA`, and use a function/command called `is.na()` to ask if data is missing.  More on this later.



We can use greater than `>` or less than `<` signs as you would expect.
```{r}
300 > 200
# [1] TRUE

0 > 999
# [1] FALSE
```

# MULTIPLE CHOICE

Which of the following will NOT return TRUE?
A. FALSE == FALSE
B. 10-5 == sqrt(25)
C. TRUE > FALSE
D. 'a' > 'b'

```{r}
FALSE == FALSE
# [1] TRUE

10-5 == sqrt(25)
# [1] TRUE

TRUE > FALSE
# [1] TRUE

'a' > 'b'
# [1] FALSE
```
**Note:** `TRUE` is greater than `FALSE` because R in the background actually uses 1 to represent `TRUE` and 0 to represent `FALSE`.  Also, `'b'` is greater than `'a'` because it's later in the alphabet. In other words, the 2nd letter is greater than the 1st letter.  This is helpful for ordering alphabetically, which we'll see later.


# Storing Data

R stores data (and everything else) as objects. New objects are created when we assign them values;
```{r}
x <- 3
y <- 2 # now check the Environment window

x+y
# [1] 5
```

# MULTIPLE CHOICE

What is the output when we execute the following code?
x <- 3
y <- 2
y <- 17.4
x+y

A. [1] 3  2  17.4
B. [1] 22.4
C. [1] 20.4
D. [1] 5



Assigning new values to existing objects over-writes the old version – and be aware there is no Ctrl-Z ‘undo’;
```{r}
y <- 17.4 # check the Environment window again

x+y
# [1] 20.4

```

* Anything after a hash (#) is ignored – e.g. comments
* Spaces don’t matter
* Capital letters do matter
    

# Reading in Data

## Where are we?

Before we can read data into R, we need to know where we are on our computer.  Just like the command line's `pwd` command, R has a command called `getwd()`.  Notice that it returns the absolute path to your home directory.
```{r}
getwd()
# [1] "C:/Users/gaugustus/Documents/Rdocs/"
```

You can point to files from anywhere on the computer RELATIVE to your current position.  If you need to change this working directory, such as to go into the new `r-intro-20170825` folder you got from GitHub, you can do so with `setwd()`.  Let's try this.  Make sure you put the path in quotes.

You can use tab complete in R Studio, so once you open the quotes, press tab to see all the files and directories listed for you.  If you type a letter, that list will shorten.

```{r}
setwd("r-intro-20170825")
getwd()
# [1] "C:/Users/gaugustus/Documents/Rdocs/r-intro-20170825"
```



## Read in using readr package   

To import a dataset, follow pop-ups from the Environment tab;
Import Dataset > From CSV...

Once you've decided on your options, you'll see the code at the bottom right tells you how you can code that yourself:

```{r}
#install.packages('readr') #uncomment this line if you have not installed readr

library(readr)
mammals <- read_delim(file = "datasets/01_mammals.txt", 
    delim = "\t", escape_double = FALSE, trim_ws = TRUE)
View(mammals)
```


By default, you'll see that a `library` command is set.  The `library` command allows us to add on to the basic features of R (also called base R).  In other words, we can add functionality to make our lives easier.  In this case, we are getting the `readr` package.  This is part of a suite of packages called the `tidyverse`.

More on those options;

* Name: Name of the data frame object that will store the whole dataset
* file: where is the file located?  Absolute or relative path
* First row as names: Does your first line have the names of the columns?
* Delimiter: What separates column values?  Tabs, commas, white space
* Skip: Do you need to skip any lines at the top?
* Trim whitespace: If there are extra spaces, get rid of them

The defaults are sensible, but R assumes you know what your data should look like – and whether it has named columns, row names etc. No software is smart enough to cope with every format that might be used by you/your colleagues to store data.

**Note:** There is also a way to input Excel files, using a package called `readxl`, also from the tidyverse.

After successfully reading in the data;

* The environment now includes a mammals object – or whatever you called the data read from file
* A copy of the data can be examined in the Excel-like data viewer – if it looks weird, find out why & fix it!

## Read in Data with base R 

You can also read in data using base R like so:

```{r}
mammals2 <- read.csv(file = "datasets/01_mammals.txt", header=TRUE, sep = "\t", stringsAsFactors = FALSE)

mammals == mammals2
#       Animal body brain
#  [1,]   TRUE TRUE  TRUE
#  [2,]   TRUE TRUE  TRUE
#  [3,]   TRUE TRUE  TRUE
#  [4,]   TRUE TRUE  TRUE
#  [5,]   TRUE TRUE  TRUE
#  [6,]   TRUE TRUE  TRUE
#  [7,]   TRUE TRUE  TRUE
#  [8,]   TRUE TRUE  TRUE
#  [9,]   TRUE TRUE  TRUE
# [10,]   TRUE TRUE  TRUE
# [11,]   TRUE TRUE  TRUE
# [12,]   TRUE TRUE  TRUE
# [13,]   TRUE TRUE  TRUE
# [14,]   TRUE TRUE  TRUE
# [15,]   TRUE TRUE  TRUE
# [16,]   TRUE TRUE  TRUE
# ...
```

We check to see if every value is equal between the dataset we read in using `readr` and the one we read in using base `R`, and see that they are the same.

# How to name my data

What’s a good name for my new object?

* Something memorable (!) and not easily-confused with other objects, e.g. X isn’t a good choice if you already have x
* Names must start with a letter or period (”.”), after that any letter, number or period is okay
* Avoid other characters; they get interpreted as math (”-”,”*”) or are hard to read (” ”) so should not be used in names
* Avoid names of existing functions – e.g. summary. Some oneletter choices (c, C, F, t, T and S) are already used by R as names of functions, it’s best to avoid these too


# What can I do with my data?

To operate on data, type commands in the Console window, just like our earlier calculator-style approach;
```{r}
str(mammals)
# ’data.frame’: 62 obs. of 2 variables:
# $ body : num 3.38 0.48 1.35 465 36.33 ...
# $ brain: num 44.5 15.5 8.1 423 119.5 ...

summary(mammals)
# body                brain
# Min. : 0.005       Min. : 0.14
# 1st Qu.: 0.600     1st Qu.: 4.25
# Median : 3.150     Median : 17.25
# Mean : 198.738     Mean : 283.13
# 3rd Qu.: 48.203    3rd Qu.: 166.00
# Max. :6654.000     Max. :5712.00
```

* str() tells us the structure of an object (i.e., it's dimensions/size and the class of the each data column)
* summary() summarizes the object and provide basic summary statistics for each column within your data

We can also use these commands on any object – e.g. the single numbers we created earlier (try it!)


There are also commands to get these statistics alone:
```{r}
min(mammals$brain)
# [1] 0.14

median(mammals$brain)
# 17.25

max(mammals$brain)
# 5712
```

These are called FUNCTIONS, and are used to do a particular task on a set of data.  Here we are accessing columns by using the dollar sign.  We are telling R that we are only interested in one column.

We can also do more sophisticated things with these commands.  Let's try a simple plot:

```{r}
plot(mammals$brain, mammals$body)
```


# Data Frames

Individual columns in data frames are identified using the `$` symbol – just seen in the str() output.

Think of $ as ‘apostrophe-S’, i.e. mammals`’S` brain.

New columns are created when you assign their values – here containing the brain weights in kilograms;


```{r}

mammals$brainkg <- mammals$brain/1000

str(mammals)
# ’data.frame’: 62 obs. of 3 variables:
# $ body : num 3.38 0.48 1.35 465 36.33 ...
# $ brain : num 44.5 15.5 8.1 423 119.5 ...
# $ brainkg: num 0.0445 0.0155 0.0081 0.423 0.1195 ...

summary(mammals$brainkg)
# Min.     1st Qu. Median Mean    3rd Qu. Max.
# 0.00014 0.00425 0.01725 0.28310 0.16600 5.71200
```

* Assigning values to existing columns over-writes existing values – again, with no warning
* With e.g. mammals$newcolumn <- 0, the new column has every entry zero; R recycles this single value, for every entry
* It’s unusual to delete columns... but if you must; use `mammals$brainkg <- NULL`


Other functions useful for summarizing data frames, and their columns;
```{r}
names(mammals)
# [1] "body" "brain"

dim(mammals) # dim is short for dimension
# [1] 62 2

length(mammals$body) # how many rows in our dataset?
# [1] 62

min(mammals$body)
# [1] 0.005

max(mammals$body)
# [1] 6654

range(mammals$body)
# [1] 0.005 6654.000

mean(mammals$brain)
# [1] 283.1342

sd(mammals$brain) # sd is short for standard deviation
# [1] 930.2789

median(mammals$brain)
# [1] 17.25

median(mammals$br) # uses pattern-matching (but hard to debug later)
# [1] 17.25
```


# Using the script window

While fine for occasional use, entering every command ‘by hand’ is error-prone, and quickly gets tedious. A much better approach is to use a Script window – open one with Ctrl-Shift-N, or the drop-down menus;

* Opens a nice editor, enables saving code (.R extension)
* Run current line (or selected lines) with Ctrl-Enter, or Ctrl-R

**An important notice:** From now on, we assume you are using a script editor.

* First-time users tend to be reluctant to switch! – but it’s worth it, ask any experienced user
* Some code in slides may be formatted for cut-and-paste into scripts – it may not look exactly like what appears in the Console window
* Exercise ‘solutions’ given as .R files
* Scripts make it easy to run slightly modified code, without re-typing everything – remember to save them as you work
* Also remember the Escape key, if e.g. your bracket-matching goes wrong

For a very few jobs, e.g. changing directories, we’ll still use drop-down menus. But commands are available, for all tasks.


# EXERCISE

Import another dataframe and call it `gapminder`. This file is located in the repo, at `datasets/02_gapminder.txt`.  Use `readr`'s `read_delim` as we did above.

Use `str()` to look at the structure of the dataframe and `summary()` to get information about the variables.

* What are its columns?
* How many rows and columns are there?
* What is the earliest year in the `year` column?
* What is the average life expectancy?
* What is the largest population?


```{r}
gapminder <- read_delim("datasets/02_gapminder.txt", 
    "\t", escape_double = FALSE, trim_ws = TRUE)

str(gapminder)
# Classes ‘tbl_df’, ‘tbl’ and 'data.frame':	1704 obs. of  6 variables:
# $ country  : chr  "Afghanistan" "Afghanistan" "Afghanistan" "Afghanistan" ...
# $ continent: chr  "Asia" "Asia" "Asia" "Asia" ...
# $ year     : int  1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...
# $ lifeExp  : num  28.8 30.3 32 34 36.1 ...
# $ pop      : int  8425333 9240934 10267083 11537966 13079460 14880372 12881816 13867957 16317921 22227415 ...
# $ gdpPercap: num  779 821 853 836 740 ...

dim(gapminder)

```


# Subsetting

## Base R

Suppose we were interested in the brain weight (i.e. 2nd column) for mammals (i.e. rows) 14, 55, & 61. How to select these multiple elements?
```{r}
mammals[c(14,55,61),1]
# [1] 0.005 0.048 0.104 # check these against data view
```

But what is `c(14,55,61)`? It’s a vector of numbers – `c()` is for combine;
```{r}
length(c(14,55,61))
# [1] 3

str(c(14,55,61))
# num [1:3] 14 55 61
```

We can select these rows and all the columns;
```{r}
mammals[c(14,55,61),]
#                           body  brain
# Lesser short-tailed shrew 0.005 0.14
# Musk shrew                0.048 0.33
# Tree shrew                0.104 2.50
```


A very useful special form of vector;
```{r}
1:10
# [1] 1 2 3 4 5 6 7 8 9 10

6:2
# [1] 6 5 4 3 2

-1:-3
# [1] -1 -2 -3
```

R expects you to know this shorthand – see e.g. its use of `1:3` in the output from `str()`, on the previous slide. For a ‘rectangular’ selection of rows and columns;
```{r}
mammals[20:22, 1:2]
#                body    brain
# Big brown bat  0.023    0.3
# Donkey         187.100 419.0
# Horse          521.000 655.0

```


Negative values correspond to dropping those rows/columns;
```{r}
mammals[-3:-62, 1:2] # everything but the first two rows, & columns 1:2
#              body      brain
# Arctic fox   3.385     44.5
# Owl monkey   0.480     15.5
```

As well as storing numbers and character strings (like "Donkey", "Big brown bat") R can also store logicals – `TRUE` and `FALSE`.
To make a new vector, with elements that are `TRUE` if body mass is above 500kg and FALSE otherwise;
```{r}

is.heavy <- mammals$body > 500

table(is.heavy) # another useful data summary command
# is.heavy
# FALSE TRUE
# 58    4
```


Which mammals were these? (And what were their masses?)
```{r}
mammals[is.heavy,] # just the rows for which is.heavy is TRUE
#                  body brain
# Asian elephant   2547 4603
# Horse            521  655
# Giraffe          529  680
# African elephant 6654 5712

> mammals[is.heavy,2] # combining TRUE/FALSE (rows) and numbers (columns)
# [1] 4603 655 680 5712
```


One final method... for now!

Instead of specifying rows/columns of interest by number, or through vectors of TRUEs/FALSEs, we can also just give the names – as character strings, or vectors of character strings.
```{r}
mammals[c("Cow","Goat","Human"),"body"]
# [1] 465.00 27.66 62.00

mammals[c("Cow","Goat","Human"),c("body","brain")]
#         body      brain
# Cow     465.00    423
# Goat    27.66     115
# Human   62.00     1320

mammals[c("Cow","Goat","Human"),2] # okay to mix & match
# [1] 423 115 1320
```

This is more typing than the other options, but is much easier to debug/reuse.

## Dplyr

Base R gives us several ways to subset our data, which is in the online notes.  However, we are going to introduce you to an other package in the tidyverse called `dplyr` which makes manipulating datasets a little easier for beginners.

If you haven't already, install dplyr
```{r}
#install.packages("dplyr")
```

Don't forget to load the package so we can use its functionality
```{r}
library(dplyr)
```

dplyr works by piping commands, like you learned to do in the command line.  Instead of the pipe `|`, we use `%>%`.
```{r}
mammals %>% select(body) %>% min()
# [1] 0.005
min(mammals$body)
# [1] 0.005
```

dplyr also comes with ways to subset our data.

If we only want to choose one column:
```{r}
mammals %>% select(body)
#      body
#      <dbl>
# 1    3.385
# 2    0.480
# 3    1.350
# 4  465.000
# 5   36.330
# 6   27.660
# 7   14.830
# 8    1.040
# 9    4.190
# 10   0.425
# ... with 52 more rows
```

If we want to make a new column, use mutate.  Don't forget we have to assign it if we want to keep the changes
```{r}
mammals <- mammals %>% mutate(NewColumn = body + brain)
mammals

#             Animal    body brain NewColumn
#              <chr>   <dbl> <dbl>     <dbl>
# 1       Arctic fox   3.385  44.5    47.885
# 2       Owl monkey   0.480  15.5    15.980
# 3  Mountain beaver   1.350   8.1     9.450
# 4              Cow 465.000 423.0   888.000
# 5        Grey wolf  36.330 119.5   155.830
# 6             Goat  27.660 115.0   142.660
# 7         Roe deer  14.830  98.2   113.030
# 8       Guinea pig   1.040   5.5     6.540
# 9           Verbet   4.190  58.0    62.190
# 10      Chinchilla   0.425   6.4     6.825
# ... with 52 more rows
```

If we want to select all columns except 1, we can do that with the `-` operator.
```{r}
mammals <- mammals %>% select(-NewColumn)
mammals
#             Animal    body brain
#              <chr>   <dbl> <dbl>
# 1       Arctic fox   3.385  44.5
# 2       Owl monkey   0.480  15.5
# 3  Mountain beaver   1.350   8.1
# 4              Cow 465.000 423.0
# 5        Grey wolf  36.330 119.5
# 6             Goat  27.660 115.0
# 7         Roe deer  14.830  98.2
# 8       Guinea pig   1.040   5.5
# 9           Verbet   4.190  58.0
# 10      Chinchilla   0.425   6.4
# ... with 52 more rows
```


Now what about rows?  For this we use te `filter` commands:
```{r}
mammals %>% filter(body > 1000)
#            Animal  body brain
#              <chr> <dbl> <dbl>
# 1   Asian elephant  2547  4603
# 2 African elephant  6654  5712
```

We can pipe several commands, just like with the command line:
```{r}
mammals %>% select(body, Animal) %>% filter(body > 1000) %>% mutate(TwiceWeight = body * 2)
#    body           Animal TwiceWeight
#   <dbl>            <chr>       <dbl>
# 1  2547   Asian elephant        5094
# 2  6654 African elephant       13308
```

We can also use outside information to help subset data.
```{r}
Animals <- c("Cow","Goat")

mammals %>% filter(Animal %in% Animals)
#   Animal   body brain
#    <chr>  <dbl> <dbl>
# 1    Cow 465.00   423
# 2   Goat  27.66   115
```



# EXERCISE

Using the `gapminder` dataframe we imported in the last exercise:

Create a new dataframe that contains only country names, years,  and life expectancies. Use this new dataframe to calculate minimum & maximum expectancies.
```{r}
new_gapminder <- gapminder %>% select(country, year, lifeExp) # BASE R solution:  gapminder[,c(1,2,5)]

head(new_gapminder)
#       country  year lifeExp
#         <chr> <int>   <dbl>
# 1 Afghanistan  1952  28.801
# 2 Afghanistan  1957  30.332
# 3 Afghanistan  1962  31.997
# 4 Afghanistan  1967  34.020
# 5 Afghanistan  1972  36.088
# 6 Afghanistan  1977  38.438

new_gapminder %>% select(lifeExp) %>% min()# BASE R solution: min(new_gapminder[,3])
# [1] 23.599

max(new_gapminder$lifeExp)
# [1] 82.603
```

# Quitting R

When you’re finished with RStudio;

* Ctrl-Q, or the drop-down menus, or entering q() at the command line all start the exit process
* You will be asked “Save workspace image to ∼/.RData?”
    + No/Don’t Save: nothing is saved, and is not available when you re-start. This is recommended, because you will do different things in each session
    + Yes: Everything in memory is stored in R’s internal format (.Rdata) and will be available when you re-start RStudio
    + Cancel: don’t quit, go back
* Writing about what you did (output from a script) often takes much longer than re-running that script’s analyses – so often, a ‘commented’ script is all the R you need to store
    
**Note:** To get rid of objects in your current session, use `rm()`, e.g. `rm(is.heavy, mammals, x, y)` ... or RStudio’s ‘broom’ button on the Environment tab.


# Summary

* In RStudio, read in data from the pop-up menu in the Environment window (or Tools menu)
* Data frames store data; can have many of these objects – and multiple other objects, too
* Identify vectors with $, subsets with square brackets
* Many useful summary functions are available, with sensible names
* Scripts are an important drudgery-avoidance tool!




References:

* Lectures from Ken Rice at University of Washington, Summer Institute for Statistical Genetics - http://faculty.washington.edu/kenrice/rintro/indexSEA15.shtml
* Scripts & Exercise from Asher Haug-Baltzell - https://github.com/asherkhb/intro_r